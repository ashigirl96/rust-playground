# 実践Rust入門

## Rustの特徴

### パフォーマンス

- Rustは、g++, gccと同レベルの速度
- Goより3倍速い
- Python3より30倍速い

### マシンコードへのコンパイル

Java(HotSpot仮想マシン)、JS(Node.js環境)は、JITコンパイラを装備している。JITとは、プログラムの実行中に収集したプロファイリング情報をもとに実行中のコードを高速なマシンコードへと徐々に置き換えるもの。

- RustはGolang, C++と同様、マシンコードを生成するので高速

### 静的型付け

- Rustのコンパイラは型推論を行う
- 変数の型宣言はほとんど省略できる

### ゼロコスト抽象化

なぜ、Rustはマシンコードを生成するGolangより速い？

→　**zero-cost abstractions**

abstractionとは、「対象から注目すべき要素を重点的に抜き出して、他は無視する手法」→　再利用性を高め、バグを防ぐ

- オブジェクト指向のポリモーフィズム(同じ名前のメソッドが属する型によって振る舞いが変わる)が抽象化の一つ
  - (Javaの)動的ディスパッチ：実行時にオブジェクトの型を調べ、その方に対応するメソッドを呼ぶ
  - (Rustの)静的ディスパッチ：コンパイル時に分かる型によって呼び出すべきメソッドを決める

- クロージャ(無名関数と自身の環境に補足した値からなるオブジェクト)
  - ガべコレの対象となるデータ構造で実現される

### 安全なシスプロ

C, C++はシスプロに使われてきたが、容易にメモリアクセスが可能で、OS開発に使われてきた。故に安全機構が欠けてきた。

- データの転記のメモリ領域あふれ
- ポインタによる誤った領域へのアクセス
- 初期化前のメモリ領域へのアクセス
- 解放後のメモリ領域へのアクセス
- データへのポインタと関数へのポインタの混同

一般的には、GCで解決するのに対して、Rustはコンパイラが賢いのでそういう問題がなくなる

### 型安全性

C言語と違って、シンタックスエラーどころかセマンティックエラー（プログラムの意味）も出してくれる



## はじめてのRust

### ルーツチェイン

- rustc: rust compoiler
- cargo: build manager && package manager
- std: standard library

- Linker: コンパイラが出力したオブジェクトファイルやライブラリを結合してABIに則って実行ファイルを出力する。OS向けに用意されてる。Linuxのgcc, binutils. macOSのXcode commandline
- ABI(Application Binary Interface): マシンコードが実行時にOSとやりとりする方法を取り決める仕様
- rustup: Rustのバージョン管理、クロスコンパイル用ターゲットのインスコ、RLSなどの開発支援ツール(ここからrustをインスコする）

### cargoコマンド

- --bin: バイナリパッケージが作られる. ルートはsrc/main.rs。cargo new のデフォルト

- --lib: ライブラリパッケージが作られる. ルートはsrc/lib.rs

- Cargo.toml: package.jsonみたいなやつ

- build: バイナリが生成される

  1. コードの検査：rustcによりエラーがないか検査

  2. コンパイル：問題なければ、rustcによりアセンブリコードへ変換し、オブジェクトファイルが生成

  3. リンカ：rustcがリンカを起動し、オブジェクトファイルとRust標準ライブラリの結合し、実行ファイルを生成 (※ libクレートはここをしない)

  

### 簡単な構文

- 感嘆符！が付いてるのはマクロ。コンパイル時に評価される
- letは右辺の評価式を変数に束縛する
- debug_assert_eq!はデバッグビルド時のみ展開される標準ライブラリ
- ;がなければ、その式で評価した値を返す
- stack.pop.expect("")で、取り出せなかった時そこで強制終了する
- whereはジェネリクスのトレイト境界を決めるもので、この境界内であればどんな値も許容する
- 「なぜならサブタイプの一般的な考え方では、親となる基底型よりも、子である派生型の方が多くの機能を 持つ(子は親の代わりができる)からです」


### バイトニックソートを実装してみる

- pub: tsのexportみたいなもの
- x: &mut [u32]とは、値をポインタ経由で”借用する”
  - mutは変更可能
  - u32は32ビット正整数
  - [u32] はu32のスライス（配列みたいなもの）
    - 数列をコピーせずに直接変更できる
- `#[allow(non_snake_case)]` 関数、変数、ライフタイム、モジュールの識別子がスネークケースでなくても良い。他にもある

#### 全順序・半順序

- 半順序集合(Partially ordered set)
  - 反射律: $\forall a: a \leq a$
  - 推移律: $\forall a, b, c: a \leq b \land b \leq c \Rightarrow a \leq c$
  - 反対称律: $\forall a, b: a \leq b \land b \leq b \Rightarrow a = b$
- 全順序集合 := 全順序律 + 半順序
  - 全順序律: $\forall a, b: a \leq b \lor b \leq b$

#### トレート境界

```rust
pub fn sort<T: Ord>(x: &mut [T], up: bool)
```

全順序の境界にすることで、NaNを含む全順序じゃないf64を許可しないようにする



```
# error[E0308]のドキュメントを表示する
$ rustc --explain 308
```



#### enum使う

```rust
sort(&mut x, true)
```

と来たとき、「何がtrueなの？」となるため、enumで定義したインタフェースを作る

インタフェースは、matchで返すものを判断する

```
use SortOrder::Ascending as Asc;
```

と出来る。なんだかTypeScriptのimportみたいだな

```rust
use crate::SortOrder::*;
```

とすると全てインポートしてくる。



#### エラーを返す

- Rustは例外を投げることでエラーを起こったことを表さず、戻り値として表現する
- `Result<T, E>` 型が用意されてる。Result型は列挙型で
  - OkとErrの２つのバリアントを持つ
  - `sort(...).is_ok` で、よかったらtrueが帰ってくる

### 構造体

- `struct Student` で構造体を定義する
- `impl Student{ fn new() -> Self { } }`
  - implブロックを使うことで、対象の型に関連関数やメソッドを追加できる

### クロージャー

```rust
|a, b| a.age.cmp(&b.age)
```

と、引数と戻り値の型注釈を付けなくても良い

#### クロージャーの型

```rust
let a = |a, b| a.cmp(&b);
let b = |a, b| a.cmp(&b);
```

としたとき、一見同じように見えるが、別の型となる。クロージャが自分専用の環境を持つことができるから！

- クロージャはそれが置かれる文脈によって、`　Fn, FnMut, FnOnce` トレイトの一部または全てを自動的に実装する

- sort_byでは比較するたびに同じクロージャを使うので、**環境へのアクセスが読み出し専用で、何度でも呼べるFnトレントを選択する**

- `Fn(&T, &T)-> Ordering`

  - 引数としてT型の不変の借用を２つ取り、Ordering型の値を返す

  

