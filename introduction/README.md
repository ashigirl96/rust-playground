# 実践Rust入門

## Rustの特徴

### パフォーマンス

- Rustは、g++, gccと同レベルの速度
- Goより3倍速い
- Python3より30倍速い

### マシンコードへのコンパイル

Java(HotSpot仮想マシン)、JS(Node.js環境)は、JITコンパイラを装備している。JITとは、プログラムの実行中に収集したプロファイリング情報をもとに実行中のコードを高速なマシンコードへと徐々に置き換えるもの。

- RustはGolang, C++と同様、マシンコードを生成するので高速

### 静的型付け

- Rustのコンパイラは型推論を行う
- 変数の型宣言はほとんど省略できる

### ゼロコスト抽象化

なぜ、Rustはマシンコードを生成するGolangより速い？

→　**zero-cost abstractions**

abstractionとは、「対象から注目すべき要素を重点的に抜き出して、他は無視する手法」→　再利用性を高め、バグを防ぐ

- オブジェクト指向のポリモーフィズム(同じ名前のメソッドが属する型によって振る舞いが変わる)が抽象化の一つ
  - (Javaの)動的ディスパッチ：実行時にオブジェクトの型を調べ、その方に対応するメソッドを呼ぶ
  - (Rustの)静的ディスパッチ：コンパイル時に分かる型によって呼び出すべきメソッドを決める

- クロージャ(無名関数と自身の環境に補足した値からなるオブジェクト)
  - ガべコレの対象となるデータ構造で実現される

### 安全なシスプロ

C, C++はシスプロに使われてきたが、容易にメモリアクセスが可能で、OS開発に使われてきた。故に安全機構が欠けてきた。

- データの転記のメモリ領域あふれ
- ポインタによる誤った領域へのアクセス
- 初期化前のメモリ領域へのアクセス
- 解放後のメモリ領域へのアクセス
- データへのポインタと関数へのポインタの混同

一般的には、GCで解決するのに対して、Rustはコンパイラが賢いのでそういう問題がなくなる

### 型安全性

C言語と違って、シンタックスエラーどころかセマンティックエラー（プログラムの意味）も出してくれる



## はじめてのRust

### ルーツチェイン

- rustc: rust compoiler
- cargo: build manager && package manager
- std: standard library

- Linker: コンパイラが出力したオブジェクトファイルやライブラリを結合してABIに則って実行ファイルを出力する。OS向けに用意されてる。Linuxのgcc, binutils. macOSのXcode commandline
- ABI(Application Binary Interface): マシンコードが実行時にOSとやりとりする方法を取り決める仕様
- rustup: Rustのバージョン管理、クロスコンパイル用ターゲットのインスコ、RLSなどの開発支援ツール(ここからrustをインスコする）

### cargoコマンド

- --bin: バイナリパッケージが作られる. ルートはsrc/main.rs。cargo new のデフォルト

- --lib: ライブラリパッケージが作られる. ルートはsrc/lib.rs

- Cargo.toml: package.jsonみたいなやつ

- build: バイナリが生成される

  1. コードの検査：rustcによりエラーがないか検査

  2. コンパイル：問題なければ、rustcによりアセンブリコードへ変換し、オブジェクトファイルが生成

  3. リンカ：rustcがリンカを起動し、オブジェクトファイルとRust標準ライブラリの結合し、実行ファイルを生成 (※ libクレートはここをしない)

  

### 簡単な構文

- 感嘆符！が付いてるのはマクロ。コンパイル時に評価される
- letは右辺の評価式を変数に束縛する
- debug_assert_eq!はデバッグビルド時のみ展開される標準ライブラリ
- ;がなければ、その式で評価した値を返す
- stack.pop.expect("")で、取り出せなかった時そこで強制終了する
- whereはジェネリクスのトレイト境界を決めるもので、この境界内であればどんな値も許容する
- 「なぜならサブタイプの一般的な考え方では、親となる基底型よりも、子である派生型の方が多くの機能を 持つ(子は親の代わりができる)からです」